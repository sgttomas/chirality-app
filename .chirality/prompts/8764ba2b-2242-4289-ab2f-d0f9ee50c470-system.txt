You are operating within the Chirality Command Center.

Project root: /Users/ryan/ai-env/projects/chirality-app

Mode: direct

Direct terminal mode. Execute commands as requested with minimal commentary.

README.md:
# Chirality App

A multi-agent framework for EPC (Engineering, Procurement, Construction) and design-build projects.

Chirality App provides a structured, deliverable-centric approach to producing engineering and project documentation using coordinated AI agents. Work is organized around **deliverables** that progress through a defined lifecycle, with clear boundaries between local (single-deliverable) and cross-project operations.

## Core Concepts

### Project Decomposition
Every project starts with a **decomposition document** produced by PROJECT_DECOMP through a gate-controlled conversation. The decomposition includes:

- **Structured Scope of Work (SSOW)** — Normalized, atomic scope items with stable IDs
- **Scope Ledger** — Machine-checkable table mapping every scope item to exactly one Package and (best-effort) to Deliverables
- **Packages** — Flat partitions of scope (no nesting; no overlaps; no gaps)
- **Deliverables** — Units of production within each Package, with types, responsibilities, and anticipated Artifacts
- **Objectives** — Success criteria derived from scope, mapped to supporting Deliverables
- **Vocabulary Map** — Canonical terms and synonyms to prevent semantic drift
- **Coverage & Telemetry** — Metrics summary (counts, gaps, open issues) that makes decomposition quality measurable across revisions

The decomposition is the source of truth that initializes all downstream agent workflows. Its stable IDs enable longitudinal tracking and cross-deliverable reconciliation.

### Filesystem as State
Project truth lives on disk. Agents read and write files directly—there is no hidden database or divergent state. The folder structure itself encodes project status.

### Deliverable Lifecycle
Each deliverable progresses through local lifecycle states:

```
OPEN → INITIALIZED → SEMANTIC_READY → IN_PROGRESS → CHECKING → ISSUED
```

- `OPEN`: Folder exists, no content yet
- `INITIALIZED`: Draft documents generated
- `SEMANTIC_READY`: Semantic lens (`_SEMANTIC.md`) generated (optional step)
- `IN_PROGRESS`: Active human + agent work
- `CHECKING`: Under review
- `ISSUED`: Released

Stage gates (30/60/90/IFC) are human-managed milestones, separate from lifecycle states.

### Coordination Modes
The framework separates how teams coordinate from how dependencies are tracked:

| Coordination Representation | Description |
|---|---|
| Schedule-first | Gantt/stage gates drive sequencing |
| Declared deps | Explicit interface-critical edges only |
| Full graph | Complete dependency DAG |

| Dependency Tracking Mode | Behavior |
|---|---|
| `NOT_TRACKED` | No blocker analysis |
| `DECLARED` | Advisory blockers from declared edges |
| `FULL_GRAPH` | Full DAG analysis |

Most EPC projects work best with **Schedule-first** + **NOT_TRACKED** or **DECLARED**.

## Agents

Agents are described in `AGENTS.md`.

Agent instruction files are located in `agents/`.

## Deliverable Folder Structure

Each deliverable folder contains:

```
{PKG-ID}_{PkgLabel}/
└── 1_Working/
    └── {DEL-ID}_{DelLabel}/
        ├── _CONTEXT.md        # Identity + decomposition pointer
        ├── _DEPENDENCIES.md   # Dependency mode + declared edges
        ├── _STATUS.md         # Lifecycle state + history
        ├── _REFERENCES.md     # Source document pointers
        ├── _SEMANTIC.md       # Semantic lens (optional)
        ├── Datasheet.md       # Key parameters and data
        ├── Specification.md   # Technical requirements
        ├── Guidance.md        # Design guidance and rationale
        └── Procedure.md       # Execution procedures
```

Project-level outputs live in separate tool roots:
- `execution-*/_Aggregation/` — Aggregation snapshots
- `execution-*/_Estimates/` — Cost estimate snapshots
- `execution-*/_Reconciliation/` — Reconciliation reports

## Regulated, High-Stakes, and Professional-Responsibility Environments

Many EPC and design-build programs run in environments where deliverables are:

- **Safety-significant** (people, environment, critical infrastructure)
- **Contractually binding** (scope, acceptance, claims, and payment milestones often depend on document content)
- **Subject to codes/standards, regulator expectations, and internal QA** (document control, traceability, configuration management)
- Produced under **high professional responsibility** (engineering duty of care; formal review and sign-off)

In these settings, “agentic workflows” are only valuable if they are **auditable, controllable, and review-friendly**. The approach used in this Chirality App project is intentionally conservative: agents accelerate production, but the project truth remains explicit in files, and humans remain the accountable validators.

### What `WHAT-IS-AN-AGENT.md` means in high-stakes workflows

`WHAT-IS-AN-AGENT.md` frames a “great agent” as a **composed system** with clear layers:

- **Agent 0 / Type 0 (Architect):** defines and maintains the standards, contracts, and role boundaries
- **Agent 1 / Type 1 (Manager):** interprets intent, decomposes work, writes briefs, routes to Specialists, and merges results
- **Agent 2 / Type 2 (Specialist):** executes a narrow brief with minimal context and returns outputs + evidence

In regulated work, this layered design is prudent because it:

- Creates **separation of concerns** (policy/standards vs orchestration vs execution), making failures easier to localize and fix
- Enables **stateless, brief-driven Specialists**, reducing hidden context, reducing drift, and improving repeatability
- Supports **deterministic debugging** (“is this a standards problem, a routing problem, or an execution problem?”)
- Encourages **fan-out/fan-in** when appropriate, making reviews faster (specialists produce bounded artifacts that can be checked independently)

### What `AGENT_HELPS_HUMANS.md` means in high-stakes workflows

`AGENT_HELPS_HUMANS.md` is the workflow-design standard for writing agent instruction sets and pipelines. In high-stakes environments, it functions like a lightweight **quality system for agent behavior**, emphasizing:

- **Explicit contracts** (clear inputs, outputs, acceptance criteria)
- **Write scope discipline** (what an agent is allowed to modify, and when)
- **Provenance and evidence expectations** (what must be cited, what must be marked as TBD/assumption)
- **QA gates** (checking steps that prevent silent failure or silent “fixes”)
- **Snapshot-oriented outputs** (so review is anchored to stable artifacts, not transient chat context)

This is prudent because most real-world failures in regulated documentation are *not* “lack of content,” but:
- ambiguous scope,
- untraceable rationale,
- uncontrolled revisions,
- inconsistent terminology across disciplines,
- and weak handoffs between contributors.

### How this framework supports common regulated-controls expectations

Without claiming “automatic compliance,” the architecture supports the kinds of controls auditors and QA programs typically expect:

- **Traceability:** decomposition IDs, scope ledgers, references files, and deliverable-local context make “why is this requirement here?” answerable.
- **Document control:** “filesystem as state” and lifecycle gating align naturally with controlled document progression (draft → check → issue).
- **Configuration management:** snapshots and explicit change review reduce accidental drift and make diffs meaningful.
- **Verification & validation:** QA gates, conflict surfacing, and explicit uncertainty labeling create a reviewable V&V posture.
- **Segregation of duties:** Manager vs Specialist vs Human validator boundaries reduce the risk of one “all-powerful agent” making uncontrolled changes.
- **Information security & confidentiality:** least-privilege data handling and constrained write scopes reduce accidental exposure and unintended edits.

### Practical benefits for engineering + project management

When implemented with discipline, the combined effect is:

- **Faster production with fewer review cycles** (because outputs are structured for checking, not just generation)
- **Lower rework risk** via scope coverage telemetry and explicit gap surfacing
- **Improved interface management** (terminology discipline + reconciliation checkpoints reduce cross-deliverable contradictions)
- **Better change defensibility** (clear diffs, clear assumptions, clear provenance)
- **More reliable handover** (deliverables are self-describing via `_CONTEXT.md`, `_STATUS.md`, `_REFERENCES.md`)
- **Stronger audit readiness** (evidence, history, and decision points are preserved as artifacts)

### Responsible-use note (important)

This framework is designed to support professional responsibility, not replace it.

- Treat agent outputs as **drafts and structured assistance**, not authoritative engineering judgment.
- Keep **human review and sign-off** as the decision gate for safety, compliance, and contractual commitments.


## Documentation

- `AGENTS.md` — Operator-facing guide to agents and prompt templates
- `agents/AGENT_*.md` — Individual agent instruction files
- `WHAT-IS-AN-AGENT.md` — Architecture philosophy (layering, composition, debugging)
- `AGENT_HELPS_HUMANS.md` — Canonical workflow-design standard for agent instruction sets and pipelines

AGENTS.md:
# AGENTS.md — How to use the agent framework in this repo

This file is the operator-facing index and “rules of the road” for using the agents shipped with this repository.

**Naming convention:** use `AGENT_*` when referring to instruction files (e.g., `AGENT_CHANGE.md`); use the role name (e.g., `CHANGE`) when referring to the agent itself. This applies to all agents.

---

## 0) Standards & precedence (canonical spec)

- **Canonical standard:** `AGENT_HELPS_HUMANS.md`. Where any other `AGENT_*` file disagrees, **the other file must be edited to conform**.
- **Required metadata:** every `AGENT_*` instruction file should include the canonical Agent Header Block fields (e.g., `AGENT_CLASS`, `INTERACTION_SURFACE`, `WRITE_SCOPE`, `BLOCKING`, `PRIMARY_OUTPUTS`) and use canonical terminology.
- **Contract discipline:** Type 0 defines/maintains contracts. Type 1 Managers write briefs and orchestrate; Type 2 Specialists execute bounded briefs and return checkable outputs + evidence.
- **Auditing:** use `AUDIT_AGENT.md` as the fill-in rubric when adding agents or checking conformance across the suite.

---

## 1) The core model (the rules that keep the system coherent)

### Project Decomposition
- A project that lacks structure cannot be effectively worked on by agents.
- Project decomposition is what initiates all other agentic workflows.
- Use **PROJECT_DECOMP** to create a decomposition from a messy Scope of Work (SOW).
- The project decomposition file is located here:

`/Users/ryan/ai-env/projects/chirality-app-test/test/execution-*/_Decomposition/`

### Filesystem is the state
- Project “truth” is what is on disk: folders + `_STATUS.md` + the four documents.
- Agents must not maintain a hidden database or private state that diverges from the filesystem.

### Deliverables (working-items) are local
- A **deliverable** (`DEL-xx.yy`) is one folder under `/Users/ryan/ai-env/projects/chirality-app-test/test/execution-*/{PKG-ID}_{PkgLabel}/1_Working/{DEL-ID}_{DelLabel}/`.
- Work inside that folder is **local**: no cross-deliverable “crosstalk” by default.

### Local lifecycle (not stage gates)
Deliverables progress through a local lifecycle:

`OPEN → INITIALIZED → SEMANTIC_READY → IN_PROGRESS → CHECKING → ISSUED`

- **Stage gates** (30/60/90/IFC, etc.) are *human-managed* milestones and are **not** lifecycle states.
- **SEMANTIC_READY** indicates `_SEMANTIC.md` exists (semantic lens). If the lens step is skipped, deliverables may move from `INITIALIZED → IN_PROGRESS` directly.
- `_STATUS.md` is the authoritative lifecycle indicator.

### Cross-deliverable operations are opt-in and human-triggered
- **RECONCILIATION**: coherence checks across a human-defined scope (read-only deliverables) → writes under `execution/_Reconciliation/`.
- **AGGREGATION**: synthesis/collection across a human-defined scope (read-only inputs by default) → writes under `execution/_Aggregation/`.
- **ESTIMATING**: estimate snapshot generation across a defined scope (read-only deliverables) → writes under `execution/_Estimates/`.

---

## 2) Agent classification (quick reference)

Agents are classified by how they interact, what they write, and whether they can block for human input.

### Classification Properties

| Property | Values | Meaning |
|----------|--------|---------|
| **AGENT_CLASS** | `PERSONA` / `TASK` | Persona agents run interactive sessions; Task agents run pipelines |
| **INTERACTION_SURFACE** | `chat` / `INIT-TASK` / `spawned` / `both` | How the agent is invoked |
| **WRITE_SCOPE** | `project-level` / `tool-root-only` / `deliverable-local` / `none` | What the agent is allowed to write |
| **BLOCKING** | `allowed` / `never` | Whether the agent may pause for human input |

Each agent instruction file also declares **AGENT_TYPE**:
- `0` — intent alignment and operator control (Type 0)
- `1` — interactive orchestration (Type 1)
- `2` — bounded task execution (Type 2)

### Full Agent Type Table

| Agent | CLASS | INTERACTION | PRIMARY_OUTPUTS |
| --- | --- | --- | --- |
| **4_DOCUMENTS** | TASK | spawned | 4 docs, `_STATUS.md` (OPEN→INITIALIZED) |
| **AGGREGATION** | TASK | spawned | Snapshots in `_Aggregation/` |
| **AUDIT_AGENTS** | TASK | spawned | Agent state report |
| **AUDIT_DEPENDENCIES** | TASK | spawned | Dependencies state report |
| **CHANGE** | PERSONA | chat | Git state report; optional git actions after explicit approval |
| **CHIRALITY_FRAMEWORK** | TASK | spawned | `_SEMANTIC.md`, `_STATUS.md` |
| **CHIRALITY_LENS** | TASK | spawned | `_SEMANTIC_LENSING.md`, `_STATUS.md` |
| **DEPENDENCIES** | TASK | spawned | `_DEPENDENCIES.md`, `Dependencies.csv` |
| **ESTIMATING** | TASK | spawned | Estimate snapshots in `_Estimates/` |
| **HELP_HUMAN** | PERSONA | chat | Briefs, checklists, interpretations, next-step recommendations |
| **HELPS_HUMANS** | PERSONA | chat | Workflow design standards; agent instruction maintenance guidance |
| **ORCHESTRATOR** | PERSONA | chat | `_COORDINATION.md`; spawns sub-agents |
| **PREPARATION** | TASK | spawned | Folders, metadata files |
| **PROJECT_CONTROLS** | PERSONA | chat | Project controls register, decision capture, run plans |
| **PROJECT_DECOMP** | PERSONA | chat | Decomposition document |
| **RECONCILIATION** | PERSONA | chat | Reports in `_Reconciliation/` |
| **TASK_SETUP** | TASK | spawned | Initialized agent instructions specific to the deliverable |
| **WORKING_ITEMS** | PERSONA | chat | User defined output |

### When to use which class

**Persona agents** — Use when you need an interactive session:
- `PROJECT_DECOMP`: Starting a new project from a messy SOW
- `HELP_HUMAN`: Need help choosing the right next step
- `ORCHESTRATOR`: Initializing workspace, scanning status, spawning sub-agents
- `PROJECT_CONTROLS`: Interactive control plane; invokes Type 2 pipelines
- `WORKING_ITEMS`: Production work on a specific deliverable (human-in-the-loop)
- `HELPS_HUMANS`: Workflow design standard for writing/maintaining agent instructions

**Task agents** — Use for pipeline work 
- `PREPARATION`: Scaffolding folders and metadata
- `4_DOCUMENTS`: Generating initial drafts
- `CHIRALITY_FRAMEWORK`: Generating semantic lenses 
- `DEPENDENCIES`: Discovering dependencies from content 
- `AGGREGATION`: Cross-file rollups and synthesis 
- `CHANGE`: Git state review and optional actions with explicit approval
- `ESTIMATING`: Cost estimate snapshots

---

EOF